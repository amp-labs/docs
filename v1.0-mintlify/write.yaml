openapi: 3.0.1
info:
  title: Ampersand public write API
  version: 1.0.0
servers:
  - url: https://write.withampersand.com/v1
paths:
  /projects/{projectId}/integrations/{integrationId}/objects/{objectName}:
    post:
      summary: Create, update, upsert or delete records
      operationId: writeRecords
      tags: ["Write"]
      parameters:
        - name: projectId
          in: path
          required: true
          schema:
            type: string
        - name: integrationId
          in: path
          required: true
          schema:
            type: string
        - name: objectName
          in: path
          required: true
          schema:
            type: string
      requestBody:
        description: Write request
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/WriteRequest"
      responses:
        200:
          description: The success response
          content:
            application/json:
              schema:
                oneOf:
                  - $ref: "#/components/schemas/WriteResponseSingleSuccess"
                  - $ref: "#/components/schemas/WriteResponseAsync"
        400:
          description: The failure response for bad request.
          content:
            text/plain:
              schema:
                type: string
                example: "required field not found"
        422:
          description: Error encountered while creating records
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/WriteResponseSingleFail"
        default:
          description: Error
          content:
            application/problem+json:
              schema:
                $ref: "#/components/schemas/ApiProblem"
  /generate-upload-url:
    get:
      summary: Generate a signed URL to upload write data to.
      operationId: generateUploadUrl
      tags: ["Upload URL"]
      parameters:
        - name: fileName
          in: query
          required: false
          schema:
            type: string
            description: The name of the file to upload
            example: records.csv
        - name: md5
          in: query
          required: false
          schema:
            type: string
            description: The base64-encoded MD5 hash of the file to upload (optional). If you attach this, you must also attach the Content-MD5 header to the upload request.
            example: NBLgJpN1XXun5+BsVUs/AA==
      responses:
        200:
          description: Signed URL
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/SignedWriteUrl"
        default:
          description: Error
          content:
            application/problem+json:
              schema:
                $ref: "#/components/schemas/ApiProblem"
components:
  schemas:
    WriteResponseAsync:
      type: object
      required:
        - operationId
      additionalProperties: false
      properties:
        operationId:
          type: string
          description: The operation ID
          example: 1234567890
    WriteRequest:
      required:
        - groupRef
        - type
      type: object
      properties:
        groupRef:
          type: string
          description:
            The ID of the user group whose SaaS instance you'd like to write data to. This is the ID that was provided
            during installation creation.
        type:
          type: string
          description: The type of write operation.
          enum: [create, update, upsert, delete]
          example: delete
        mode:
          type: string
          description: The mode of write operation. Default is synchronous.
          enum: [synchronous, bulk] #          enum: [synchronous, async, bulk]
          example: single
        record:
          type: object
          description: The record to write in case of non-bulk writes.
          example:
            {
              "email": "david@withampersand.com",
              "warmthScore": "ready-for-close",
            }
        #        records:
        #          type: array
        #          description: The records to write in case of non-bulk writes.
        #          example:
        #            [{
        #             "email": "david@withampersand.com",
        #             "warmthScore": "ready-for-close",
        #           }]
        recordsCSV:
          type: string
          description:
            The records to write, in a CSV string. Max size limit of data is 10 MiB.
            For bulk writes, you must provide either recordsCSV or recordsURL.
          example: "column1,column2\nvalue1,value2\nvalue3,value4"
        recordsURL:
          type: string
          description:
            Either a public URL to download the records in CSV format, or a `reference` returned by `/generate-upload-url`.
            Max size limit of CSV data is 150 MiB.
            You can provide either recordsCSV or recordsURL.
            For bulk writes, you must provide either recordsCSV or recordsURL.
          example: https://example.com/records.csv
        primaryKey:
          type: string
          description: The name of the primary key field for bulk write (required for upsert, update and delete)
          example: id
    WriteResponseSingleSuccess:
      type: object
      required:
        - result
      additionalProperties: false
      properties:
        result:
          $ref: "#/components/schemas/WriteResult"
    WriteResponseSingleFail:
      type: object
      required:
        - errors
      additionalProperties: false
      properties:
        errors:
          type: array
          description: Error messages resulted in failures
          items:
            type: string
            description: errors messages when some unexpected event happened, but write to provider was successful
            example: "The record with ID 003Dp0X#@RG7IAP was not found"
        result:
          $ref: "#/components/schemas/WriteResult"
        warnings:
          type: array
          description: Warnings messages when some unexpected event happened, but not blocking failures
          items:
            type: string
            description: Warning messages for unexpected events
            example: "Ampersand Operation failed to be updated"
        operationId:
          type: string
          description: The operation ID
          example: acb0d75a-1b59-4aad-a191-48c5b75ea9e4
    WriteResult:
      type: object
      required:
        - success
      additionalProperties: false
      properties:
        success:
          type: boolean
          description: Whether the operation was successful
          example: true
        data:
          type: object
          description: The data returned by the operation
          example: { "email": "david@ampersand.com" }
        recordId:
          type: string
          description: The ID of the object
          example: 003Dp0X#@RG7IAP
    SignedWriteUrl:
      type: object
      required:
        - url
        - reference
      properties:
        url:
          type: string
          description: The signed URL to upload the zip file to.
        reference:
          type: string
          description: The WriteRequest.RecordsURL value to pass back in the write request. It will start with "gs://".
    Problem:
      description: |
        A Problem Details object (RFC 9457).

        Additional properties specific to the problem type may be present.
      type: object
      properties:
        type:
          type: string
          format: uri
          description: An absolute URI that identifies the problem type
          default: about:blank
        href:
          type: string
          format: uri
          description: An absolute URI that, when dereferenced, provides human-readable documentation for the problem type (e.g. using HTML).
        title:
          type: string
          description: A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
          example: Service Unavailable
        status:
          type: integer
          format: int32
          description: The HTTP status code generated by the origin server for this occurrence of the problem.
          minimum: 400
          maximum: 600
          exclusiveMaximum: true
          example: 503
        detail:
          type: string
          description: A human-readable explanation specific to this occurrence of the problem
        instance:
          type: string
          format: uri
          description: An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
      example:
        type: urn:problem-type:exampleOrganization:exampleProblem # "exampleOrganization" should be a short identifier for the organization that defines the problem type. "belgif" is used for problem types standardized in the Belgif REST guide
        href: "https://www.belgif.be/specification/rest/api-guide/#standardized-problem-types" # optional, should refer to documentation of the problem type, either of a belgif standardized or a custom problem type
        title: Description of the type of problem that occurred
        status: 400 # HTTP response status, appropriate for the problem type
        detail: Description of specific occurrence of the problem
        instance: urn:uuid:123e4567-e89b-12d3-a456-426614174000
    ApiProblem:
      type: object
      allOf:
        - $ref: "#/components/schemas/Problem"
      properties:
        subsystem:
          type: string
          description: The subsystem that generated the problem
          example: "api"
        time:
          type: string
          format: date-time
          description: The time the problem occurred, formatted as RFC-3339
          example: "2024-04-22T18:55:28.456076Z"
        requestId:
          type: string
          description: A unique identifier for the request, useful for debugging
          example: "89eb1ffb-2a54-4105-aaae-7bf990f1aa69#87715"
        causes:
          type: array
          items:
            type: string
            description: A brief description of something which caused the problem
            example: "database connection failed"
          example:
            - "database connection failed"
            - "database query failed"
            - "unable to fetch user"
          description: |
            A list of problems that caused this problem. This can be used to represent multiple
            root causes. There is no guaranteed ordering of the causes.
        remedy:
          type: string
          description: A brief description of how to resolve the problem
          example: "Shorten your input to be under 100 characters"
        supportEmail:
          type: string
          format: email
          description: An email address to contact for support
          example: "support@withampersand.com"
        supportPhone:
          type: string
          description: A phone number to contact for support
          example: "+1-555-555-5555"
        supportUrl:
          type: string
          format: uri
          description: A URL to contact for support
          example: "https://withampersand.com/support"
        retryable:
          type: boolean
          description: Whether the request can be retried
          example: false
        retryAfter:
          type: string
          format: date-time
          description: A timestamp after which the request can be retried, formatted as RFC-3339
          example: "2024-04-22T18:55:28.456076Z"
        context:
          type: object
          description: Additional context for the problem
          additionalProperties: true
          example:
            name: "Rick Sanchez"
    InputValidationProblem:
      type: object
      allOf:
        - $ref: "#/components/schemas/ApiProblem"
      properties:
        issues:
          type: array
          items:
            $ref: "#/components/schemas/InputValidationIssue"
      example:
        type: about:blank
        title: Bad Request
        status: 400
        detail:  "The input message is incorrect"
        instance: 123456-1234-1235-4567489798
        issues:
          - type: about:blank
            detail: exampleNumericProperty should be numeric # detail is optional
            in: path
            name: exampleNumericProperty
            value: abc
          - type: about:blank
            title: "Input isn't valid with respect to schema"
            detail: "examplePropertyWithPattern a2345678901 doesn't match pattern '^\\d{11}$'"
            in: body
            name: items[0].examplePropertyWithPattern # location within the body
            value: "a2345678901"
    InputValidationIssue:
      type: object
      description: |
        An issue detected during input validation.
      allOf:
        - $ref: "#/components/schemas/ApiProblem"
      properties:
        in:
          type: string
          description: The location of the invalid input
          enum:
            - body
            - header
            - path
            - query
        name:
          type: string
          description: The name of the invalid input
        value:
          description: The value of the erroneous input
          # no type specified, allowing any type. This is valid in OpenAPI even though some editors may indicate an error
    Manifest:
      type: object
      description: This is the schema of the manifest file that is used to define the integrations of the project.
      required:
        - specVersion
        - integrations
      properties:
        specVersion:
          type: string
          description: The version of the manifest spec that this file conforms to.
        integrations:
          type: array
          items:
            $ref: '#/components/schemas/Integration'

    Integration:
      type: object
      required:
        - name
        - provider
      properties:
        name:
          type: string
        displayName:
          type: string
        provider:
          type: string
        read:
          $ref: '#/components/schemas/IntegrationRead'
        write:
          $ref: '#/components/schemas/IntegrationWrite'
        proxy:
          $ref: '#/components/schemas/IntegrationProxy'

    IntegrationProxy:
      type: object
      properties:
        enabled:
          type: boolean

    IntegrationRead:
      type: object
      properties:
        objects:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationObject'

    IntegrationWrite:
      type: object
      properties:
        objects:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationWriteObject'

    # This is currently only used for read actions.
    # Once we figure out whether to share the same type for both read and write, or use
    # different types, we can rename this to IntegrationReadObject if appropriate.
    IntegrationObject:
      type: object
      required:
        - objectName
        - destination
        - schedule
      properties:
        objectName:
          type: string
        destination:
          type: string
        schedule:
          type: string
        requiredFields:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationField'
        optionalFields:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationField'
        optionalFieldsAuto:
          $ref: '#/components/schemas/OptionalFieldsAutoOption'

    # We might end up using the same IntegrationObject type for both read and write,
    # but for now we're introducing a new type to keep them separate, and not renaming the
    # existing IntegrationObject.
    IntegrationWriteObject:
      type: object
      required:
        - objectName
      properties:
        objectName:
          type: string

    HydratedIntegration:
      type: object
      required:
        - name
        - provider
      properties:
        name:
          type: string
        displayName:
          type: string
        provider:
          type: string
        read:
          $ref: '#/components/schemas/HydratedIntegrationRead'
        write:
          $ref: '#/components/schemas/HydratedIntegrationWrite'
        proxy:
          $ref: '#/components/schemas/HydratedIntegrationProxy'

    HydratedIntegrationProxy:
      type: object
      properties:
        enabled:
          type: boolean

    HydratedIntegrationRead:
      type: object
      properties:
        objects:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationObject'

    HydratedIntegrationWrite:
      type: object
      properties:
        objects:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationWriteObject'

    # This is currently only used for read actions.
    # Once we figure out whether to share the same type for both read and write, or use
    # different types, we can rename this to HydratedIntegrationReadObject if appropriate.
    HydratedIntegrationObject:
      type: object
      required:
        - objectName
        - displayName
        - destination
        - schedule
      properties:
        objectName:
          type: string
        displayName:
          type: string
        destination:
          type: string
        schedule:
          type: string
        requiredFields:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationField'
        optionalFields:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationField'
        optionalFieldsAuto:
          $ref: '#/components/schemas/OptionalFieldsAutoOption'
        allFields:
          description: This is a list of all fields on the object for a particular SaaS instance. This is used to populate the UI during configuration.
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationField'

    # We might end up using the same HydratedIntegrationObject type for both read and write,
    # but for now we're introducing a new type to keep them separate, and not renaming the
    # existing IntegrationObject.
    HydratedIntegrationWriteObject:
      type: object
      required:
        - objectName
        - displayName
      properties:
        objectName:
          type: string
        displayName:
          type: string

    OptionalFieldsAutoOption:
      type: string
      enum: [all]

    IntegrationField:
      oneOf:
        - $ref: '#/components/schemas/IntegrationFieldExistent'
        - $ref: '#/components/schemas/IntegrationFieldMapping'

    IntegrationFieldExistent:
      type: object
      required:
        - fieldName
      properties:
        fieldName:
          type: string

    IntegrationFieldMapping:
      type: object
      required:
        - mapToName
      properties:
        mapToName:
          type: string
        mapToDisplayName:
          type: string
        default:
          type: string
        prompt:
          type: string

    HydratedIntegrationField:
      oneOf:
        - $ref: '#/components/schemas/HydratedIntegrationFieldExistent'
        - $ref: '#/components/schemas/IntegrationFieldMapping'

    HydratedIntegrationFieldExistent:
      type: object
      required:
        - fieldName
        - displayName
      properties:
        fieldName:
          type: string
        displayName:
          type: string

  securitySchemes:
    APIKeyHeader:
      type: apiKey
      name: X-Api-Key
      in: header
    APIKeyQueryParam:
      type: apiKey
      name: apiKey
      in: query
    Bearer:
      type: apiKey
      name: Authorization
      in: header
