---
title: "Build your own unified API"
sidebarTitle: "Unified API"
---

## What is a unified API?

A unified API provides a single, consistent interface to interact with multiple third-party services. Instead of learning each provider's unique schema, you define one schema that works across all of them.

<Note>
Unlike traditional unified API providers that force you into their predefined models, Ampersand lets you design your own unified schema while providing templates to get started quickly.
</Note>

## Why build a unified API?

- **Faster integration development** - Add new providers without changing your application logic
- **Consistent data model** - Your application works with one schema regardless of the source
- **Gradual migration** - Start with compatibility mode, customize as needed
- **No vendor lock-in** - You control the schema, not limited by lowest common denominator

## Core concepts

### Object mapping
Map different provider objects to a unified name:

```yaml
# Salesforce Account → company
# HubSpot companies → company  
# Pipedrive organizations → company

- objectName: account        # Salesforce
  mapToName: company
- objectName: companies      # HubSpot
  mapToName: company
- objectName: organizations  # Pipedrive
  mapToName: company
```

### Field standardization
Create consistent field names across providers:

```yaml
# Different providers, same unified fields
requiredFields:
  - fieldName: name           # Salesforce
    mapToName: company_name
  - fieldName: name           # HubSpot
    mapToName: company_name
  - fieldName: account_name   # Zoho
    mapToName: company_name
```

### Raw data access

Every payload includes both unified fields AND the original provider data:

```json
{
  "mappedFields": {
    "remote_id": "001abc", // Original provider ID
    "name": "Acme Corp",
    "remote_created_at": "2024-01-15",  // Original creation timestamp
    "remote_updated_at": "2024-08-23"   // Original update timestamp
  },
  "raw": {
    // Complete original response from provider
    "Id": "001abc",
    "Name": "Acme Corp",
    "CreatedDate": "2024-01-15T10:30:00Z",
    "SystemModstamp": "2024-08-23T14:20:07Z"
  }
}
```

**Key fields:**
- `mappedFields` - Your unified schema (like merge.dev's common model)
- `raw` - Original provider response (like merge.dev's remote_data, but always included)
- `remote_id` - Preserves the provider's original ID for lookups
- `remote_created_at` / `remote_updated_at` - Original provider timestamps

<Tip>
Unlike merge.dev where you need `include_remote_data=true`, Ampersand always provides raw data alongside mapped fields in every payload.
</Tip>

### Provider-specific access
Keep unique fields available without compromising the unified model:

```yaml
# Unified fields + provider-specific
requiredFields:
  - fieldName: name
    mapToName: company_name
  # Salesforce-specific fields remain accessible via raw
  - fieldName: accountnumber
  - fieldName: type
  - fieldName: sla__c  # Custom fields too
```

## Examples

### CRM unified API

Create a unified CRM that works across Salesforce, HubSpot, Pipedrive, and more:

<CodeGroup>
```yaml Salesforce
- objectName: account
  mapToName: company
  requiredFields:
    - fieldName: id
      mapToName: remote_id
    - fieldName: name
      mapToName: name
    - fieldName: website
      mapToName: website
    - fieldName: createddate
      mapToName: remote_created_at
    - fieldName: lastmodifieddate
      mapToName: remote_updated_at
```

```yaml HubSpot
- objectName: companies
  mapToName: company
  requiredFields:
    - fieldName: hs_object_id
      mapToName: remote_id
    - fieldName: name
      mapToName: name
    - fieldName: website
      mapToName: website
    - fieldName: createdate
      mapToName: remote_created_at
    - fieldName: hs_lastmodifieddate
      mapToName: remote_updated_at
```

```yaml Result Payload
{
  "mappedFields": {
    "remote_id": "22575402281",
    "name": "Acme Corp",
    "website": "acme.com",
    "remote_created_at": "2024-08-23T14:04:57.739Z",
    "remote_updated_at": "2024-08-23T14:20:07.660Z"
  },
  "raw": {
    "id": "22575402281",
    "name": "Acme Corp",
    "domain": "acme.com",
    "createdAt": "2024-08-23T14:04:57.739Z",
    "updatedAt": "2024-08-23T14:20:07.660Z",
    "hs_object_id": "22575402281"
  }
}
```
</CodeGroup>

### Ticketing unified API

Standardize tickets across Jira, Linear, Zendesk, and ServiceNow:

<CodeGroup>
```yaml Jira
- objectName: issue
  mapToName: ticket
  requiredFields:
    - fieldName: id
      mapToName: remote_id
    - fieldName: summary
      mapToName: title
    - fieldName: status
      mapToName: status
```

```yaml Linear
- objectName: issues
  mapToName: ticket
  requiredFields:
    - fieldName: id
      mapToName: remote_id
    - fieldName: title
      mapToName: title
    - fieldName: state
      mapToName: status
```

```yaml Result
{
  "mappedFields": {
    "remote_id": "LIN-123",
    "title": "Fix bug",
    "status": "in_progress"
  },
  "raw": {
    "id": "LIN-123",
    "title": "Fix bug",
    "state": { "name": "In Progress" },
    "priority": 2,
    "assignee": { "id": "user-456" }
  }
}
```
</CodeGroup>

## Comparison with merge.dev

| Feature | merge.dev | Ampersand |
|---------|-----------|-----------|
| **Schema Control** | Fixed common model | You define the schema |
| **Raw Data** | Via `include_remote_data=true` | Always included in every payload |
| **Remote IDs** | `remote_id` field | `remote_id` in mappedFields |
| **Timestamps** | `remote_created_at`, `remote_updated_at` | Same, map from provider fields |
| **Custom Fields** | Via remote_data or field mappings | Direct access in `raw` object |
| **Provider Coverage** | Limited to common fields | All fields available via `raw` |
| **Data Delivery** | Pull only | Push (webhooks) + Pull |

## Best practices

<AccordionGroup>
  <Accordion title="Always map remote_ fields" defaultOpen>
    Include `remote_id`, `remote_created_at`, and `remote_updated_at` in your schema for proper tracking and syncing.
  </Accordion>
  
  <Accordion title="Use raw for provider-specific logic">
    Access custom or unmapped fields via the `raw` object without modifying your unified schema.
  </Accordion>

  <Accordion title="Start with core fields">
    Begin with fields that exist across all your target providers, then add provider-specific fields as needed.
  </Accordion>
  
  <Accordion title="Use consistent naming">
    Establish naming conventions early (e.g., `snake_case` for unified fields).
  </Accordion>
  
  <Accordion title="Handle missing fields gracefully">
    Use optional fields for data that might not exist in all providers.
  </Accordion>
</AccordionGroup>

## Complete examples

View full working examples in our samples repository:

<CardGroup cols={2}>
  <Card 
    title="Unified CRM" 
    href="https://github.com/amp-labs/samples/tree/main/unifiedCRM"
    icon="building"
  >
    Salesforce, HubSpot, Zoho, Dynamics 365
  </Card>
  <Card 
    title="Unified Ticketing" 
    href="https://github.com/amp-labs/samples/tree/main/unifiedTicketing"
    icon="ticket"
  >
    Jira, Linear, Zendesk
  </Card>
</CardGroup>

## Migration from merge.dev

<Steps>
  <Step title="Use compatible templates">
    Start with our merge.dev-compatible templates:
    ```bash
    git clone https://github.com/amp-labs/samples.git
    cd samples

    # CRM template
    cd unifiedCRM
    amp deploy --project=my-project
    
    # Ticketing template
    cd unifiedTicketing
    amp deploy --project=my-project
    ```
  </Step>
  
  <Step title="Update Your Code">
    Ampersand provides both mapped and raw data in every payload:
    ```javascript
    // merge.dev: Separate calls for mapped vs raw data
    const contacts = await merge.crm.contacts.list()
    const contactsWithRaw = await merge.crm.contacts.list({ 
      include_remote_data: true 
    })
    
    // Ampersand: Everything in one webhook payload
    app.post('/webhook/contacts', (req, res) => {
      const { mappedFields, raw } = req.body.result
      
      // Use unified fields
      console.log(mappedFields.name, mappedFields.remote_id)
      
      // Access provider-specific fields
      console.log(raw.CustomField__c)
      
      res.sendStatus(200)
    })
    ```
  </Step>
  
  <Step title="Map remote_ fields">
    Always map the provider's ID and timestamp fields:
    ```yaml
    requiredFields:
      - fieldName: id              # Salesforce
        mapToName: remote_id
      - fieldName: createddate
        mapToName: remote_created_at
      - fieldName: lastmodifieddate
        mapToName: remote_updated_at
      - fieldName: name
        mapToName: name
    ```
  </Step>

  <Step title="Customize gradually">
    Add provider-specific fields as needed without changing your schema:
    ```javascript
    // Provider-specific logic using raw data
    if (provider === 'salesforce' && raw.AccountNumber) {
      // Handle Salesforce-specific field
    }
    ```
  </Step>
</Steps>

## Related resources

- [Object and Field Mapping](/object-and-field-mapping) - Technical details on mapping configuration
- [Read Actions](/read-actions) - How to read data from unified objects
- [Write Actions](/write-actions) - Writing data back through unified mappings