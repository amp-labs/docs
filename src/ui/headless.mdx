---
title: Headless React Library
description: A flexible React library for managing connections and installations with your custom UI components
---

# Headless React Library

The Headless React Library provides a powerful foundation for managing connections and installations while giving you complete control over your UI implementation. This library is designed for developers who want to build custom user interfaces while leveraging robust connection management capabilities.

<Note>
The Headless React Library is in beta. 
- The lib may change in non backwards-compatible ways.
- Experimental features are in progress.
</Note>

## Overview

The Headless React Library provides a series of react hooks that manage connections, installations, 
and other configuration data with queries and mutation hooks. The hooks may be used together 
or independently from the @amp-labs/react embeddable UI components.

The Headless React Library separates the logic of connection and installation management from the UI components, allowing you to:

- Manage connections to various services and platforms
- Handle installation processes
- Implement custom UI components
- Maintain full control over the user experience

## Installation 
The headless react lib is currently in the same package as our embeddable UI in @amp-labs/react. 

```bash
npm install @amp-labs/react
# or
yarn add @amp-labs/react-
```

## Core Features

### Installation provider
The `InstallationProvider` is a React context provider that provides shared parameters. It wraps your component at the installation level and provides access to installation-related functionality through hooks.

The provider requires the following props:
- `integration`: The name of your integration
- `consumerRef`: A unique identifier for the consumer
- `groupRef`: A unique identifier for the group
- `consumerName`: (Optional) A display name for the consumer
- `groupName`: (Optional) A display name for the group

This provider is essential for using any of the headless hook in your application.

```tsx
import {
  AmpersandProvider,     // needed for any component/hooks in @amp-labs/react
  InstallationProvider,  // provider needed for headless hooks
} from "@amp-labs/react"

// env variables
const apiKey = import.meta.env.VITE_AMP_API_KEY;
const projectId = import.meta.env.VITE_AMP_PROJECT_ID;

const PARAMS = {
  integration,
  provider: "salesforce",
  consumerRef: "consumer-test-1",
  groupRef: "group-test-1",
  integration: "my-salesforce-integration"
};

function App() {
  return (
    // Provider for the Ampersand SDK
    <AmpersandProvider options={{ apiKey: apiKey, projectId: projectId }}>
      {/* Provider for the installation specific headless library */}
      <InstallationProvider
        integration={PARAMS.integration}
        consumerRef={PARAMS.consumerRef}
        groupRef={PARAMS.groupRef}
      >
        {/* Builder Custom Installation Component */}
        <MyComponent />
      </InstallationProvider>
    </AmpersandProvider>
  );
}
```

#### useInstallationProps
A hook that provides access to the installation context values:
- `integrationNameOrId`: string
- `consumerRef`: string
- `consumerName`: string | undefined
- `groupRef`: string
- `groupName`: string | undefined


### Connection Management

The library provides hooks and utilities for managing connections:

The `useConnection` hook provides access to the current connection state and management functions. It returns an object with the following properties:

- `connection`: The current Connection object, or null if not connected
- `error`: Any error that occurred during connection operations
- `isPending`: Boolean indicating if a connection operation is in progress
- `isFetching`: Boolean indicating if connection data is being fetched
- `isError`: Boolean indicating if an error occurred
- `isSuccess`: Boolean indicating if the last operation was successful

This hook is useful for building custom connection management UIs and handling connection states in your application.

```tsx
import { useConnection, ConnectProvider } from '@amp-labs/react';

function MyComponent() {
  const { 
    connection, // Connection object
    error,
    isPending,
    isFetching,
    isError,
    isSuccess,
  } = useConnection();

  // Use these values to build your custom UI
  return (
    <div>
      {connection ? (
        // embeddable ui component
        <ConnectProvider
            provider={PARAMS.provider}
            consumerRef={PARAMS.consumerRef}
            groupRef={PARAMS.groupRef}
            onConnectSuccess={(connection) => {
              console.log("Connection successful:", connection);
            }}
            onDisconnectSuccess={(connection) => {
              console.log("Disconnection successful:", connection);
            }}
          />
        </div>
      ) : (
        <MyInstallIntegrationComponent/>
      )}
    </div>
  );
}
```

### Installation Management
The `useInstallation` hook provides access to the current installation state and management functions. It returns an object with the following properties:

- `installation`: The current Installation object, or null if not installed
- `error`: Any error that occurred during installation operations
- `isPending`: Boolean indicating if an installation operation is in progress
- `isFetching`: Boolean indicating if installation data is being fetched
- `isError`: Boolean indicating if an error occurred
- `isSuccess`: Boolean indicating if the last operation was successful

This hook is useful for building custom installation management UIs and handling installation states in your application.

Handle installation processes with the installation hooks:

```tsx
import { useInstallation } from '@amp-labs/react';

function InstallationComponent() {
  const { installation } = useInstallation();

  return (
    <div>
      {installation ? (
       <div>Installation Installed</div>
      ) : (
        <div>Configure Installation</div>
      )}
    </div>
  );
}
```

### Installation Mutation Hooks

The following hooks provide granular control over installation operations:

- `useCreateInstallation`: Creates a new installation with the provided configuration
- `useUpdateInstallation`: Updates an existing installation with new configuration
- `useDeleteInstallation`: Removes an existing installation

These hooks can be used individually or together to build custom installation flows:
- `useCreateInstallation`: Creates a new installation with the provided configuration
  - `createInstallation`: tanstack-query mutation function to create a new installation
  - `isPending`: Boolean indicating if creation is in progress
  - `error`: Any error that occurred during creation
  - `errorMsg`: String message describing the error
  - `isIdle`: Boolean indicating if no operation has been performed yet
  - `isSuccess`: Boolean indicating if creation was successful

Mutation hooks follow the same convention:

#### useCreateInstallation
Creates a new installation:
```typescript
{
  createInstallation: (params: {
    config: InstallationConfigContent;
    onSuccess?: (data: Installation) => void;
    onError?: (error: Error) => void;
    onSettled?: () => void;
  }) => void;
  isIdle: boolean;
  isPending: boolean;
  error: Error | null;
  errorMsg: string | null;
} = useCreateInstallation()
```

#### useUpdateInstallation
Updates an existing installation:
```typescript
{
  updateInstallation: (params: {
    config: InstallationConfigContent;
    onSuccess?: (data: Installation) => void;
    onError?: (error: Error) => void;
    onSettled?: () => void;
  }) => void;
  isIdle: boolean;
  isPending: boolean;
  error: Error | null;
  errorMsg: string | null;
} = useUpdateInstallation()
```

#### useDeleteInstallation
Deletes an installation:
```typescript
{
  deleteInstallation: (params: {
    onSuccess?: () => void;
    onError?: (error: Error) => void;
    onSettled?: () => void;
  }) => void;
  isIdle: boolean;
  isPending: boolean;
  error: Error | null;
  errorMsg: string | null;
} = useDeleteInstallation()
```

```tsx
import { useCreateInstallation } from '@amp-labs/react';

function InstallationForm() {
  const {
    createInstallation,
    isPending,
    error,
    errorMsg,
  } = useCreateInstallation();

  const handleSubmit = async (e) => {
    createInstallation({
        // Add your installation config here
        config: {
          read: {
            objects: {
              contacts: {
                objectName: 'contacts',
                selectedFieldsAuto: 'all',
              },
            }
          };
        }, 
        onSuccess: (data) => {
            console.log("Installation created", { installation: data });
        },
        onError: (error) => {
            console.error("Installation creation failed", { error });
        },
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <button 
        type="submit"
        disabled={isPending}
      >
        {isPending ? 'Creating...' : 'Create Installation'}
      </button>
      {error && <div className="error">{errorMsg}</div>}
    </form>
  );
}

```


## useManifest
Retrieves and manages manifest data from `amp.yaml` and the customer's SaaS instance:
- access to readObjects, required fields, optional fields
- access to fields and metadata from providers 

```typescript
{
  getReadObject: (objectName: string) => {
    object: HydratedIntegrationObject | null;
    getRequiredFields: () => HydratedIntegrationField[] | null;
    getOptionalFields: () => HydratedIntegrationField[] | null;
  };
  getCustomerFieldsForObject: (objectName: string) => HydratedIntegrationField[] | null;
  getCustomerFieldsMetadataForObject: (objectName: string) => {
    allFieldsMetaData: { [field: string]: FieldMetadata } | null; // map all fields metadata
    getField: (field: string) => FieldMetadata | null;
  };
  data: HydratedRevision | undefined;
  isPending: boolean;
  isFetching: boolean;
  isError: boolean;
  isSuccess: boolean;
  error: Error | null;
}
```

### destructuring objects and metadata from manifest


```tsx
  // ----------------------------------
  // Manifest: Objects & Metadata
  // ----------------------------------
  const { getCustomerFieldsMetadataForObject, data: manifest } = useManifest();

  // Selected object (Builder selected object)
  const selectedObject = manifest?.content?.read?.objects?.[0]; // select the object you want

  // Metadata
  const metadata =
    selectedObject &&
    getCustomerFieldsMetadataForObject(selectedObject.objectName);
  const allFields = metadata?.allFieldsMetaData; // provider (i.e. Saleforce) fields with metadata
  const allFieldsArray = allFields ? Object.values(allFields) : []; // convert to array for mapping inputs
```

### See full example for passing provider fields into Select component: 
https://github.com/amp-labs/headless-basic-app/blob/main/src/components/FieldMappingTable/FieldMappingTable.tsx


## Config State Management 
Managing the configuration state that needs to be passed into the Installation can be complex with deep nested objects and need to manage this state locally. 
The useConfig hook is provided to simplify local state management of the config object by providing flexible utilities to manipulate the config directly or 
simply through a set of setters and getters. 

### useConfig
Provides access to configuration management functionality for installations. This hook is essential for managing the configuration state of your integration, including read and write object configurations.

```typescript
{
  draft: InstallationConfigContent;  // Current draft configuration
  get: () => InstallationConfigContent;  // Get current configuration
  reset: () => void;  // Reset to installation's current config
  setDraft: (config: InstallationConfigContent) => void;  // Update draft config
  readObject: (objectName: string) => ReadObjectHandlers;  // Manage read object config
  writeObject: (objectName: string) => WriteObjectHandlers;  // Manage write object config
}
```

#### ReadObjectHandlers
```typescript
{
  object: BaseReadConfigObject | undefined;  // Current read object configuration
  getSelectedField: (fieldName: string) => boolean;  // Check if field is selected
  setSelectedField: (params: { fieldName: string; selected: boolean }) => void;  // Toggle field selection
  getFieldMapping: (fieldName: string) => string | undefined;  // Get field mapping
  setFieldMapping: (params: { fieldName: string; mapToName: string }) => void;  // Set field mapping
}
```

#### WriteObjectHandlers (advanced)
```typescript
{
  object: BaseWriteConfigObject | undefined;  // Current write object configuration
  setEnableWrite: () => void;  // Enable write for object
  setDisableWrite: () => void;  // Disable write for object
  getWriteObject: () => BaseWriteConfigObject | undefined;  // Get write object config
  getSelectedFieldSettings: (fieldName: string) => FieldSetting | undefined;  // Get field settings
  setSelectedFieldSettings: (params: { fieldName: string; settings: FieldSetting }) => void;  // Update field settings
  getDefaultValues: (fieldName: string) => FieldSettingDefault | undefined;  // Get default values
  setDefaultValues: (params: { fieldName: string; value: FieldSettingDefault }) => void;  // Set default values
  getWriteOnCreateSetting: (fieldName: string) => FieldSettingWriteOnCreateEnum | undefined;  // Get write on create setting
  setWriteOnCreateSetting: (params: { fieldName: string; value: FieldSettingWriteOnCreateEnum }) => void;  // Set write on create setting
  getWriteOnUpdateSetting: (fieldName: string) => FieldSettingWriteOnUpdateEnum | undefined;  // Get write on update setting
  setWriteOnUpdateSetting: (params: { fieldName: string; value: FieldSettingWriteOnUpdateEnum }) => void;  // Set write on update setting
}
```

#### Usage Examples

1. Basic Configuration Management:
```typescript
function ConfigManager() {
  const config = useConfig();
  
  // Get current configuration
  const currentConfig = config.get();
  
  // Update draft configuration directly
  config.setDraft({
    provider: "salesforce",
    read: {
      objects: {
        Contact: {
          objectName: "Contact",
          schedule: "0 0 * * *",
          destination: "contacts",
          selectedFields: {
            "Name": true,
            "Email": true
          }
        }
      }
    }
  });
  
  // Reset to installation's current config 
  config.reset();
}
```

2. Managing Read Object Configuration:
```typescript
function ReadObjectConfig() {
  const config = useConfig();
  const contactConfig = config.readObject("Contact");
  
  // Check if field is selected
  const isNameSelected = contactConfig.getSelectedField("Name");
  
  // Toggle field selection
  contactConfig.setSelectedField({ fieldName: "Email", selected: true });
  
  // Set field mapping
  contactConfig.setFieldMapping({ 
    fieldName: "Email", 
    mapToName: "email_address" 
  });
  
  // Get field mapping
  const mappedField = contactConfig.getFieldMapping("email_address");
}
```

3. Managing Advanced Write Object Configuration:
```typescript
function WriteObjectConfig() {
  const config = useConfig();
  const contactWriteConfig = config.writeObject("Contact");
  
  // Enable write for Contact object
  contactWriteConfig.setEnableWrite();
  
  // Set field settings
  contactWriteConfig.setSelectedFieldSettings({
    fieldName: "Email",
    settings: {
      writeOnCreate: "ALWAYS",
      writeOnUpdate: "ALWAYS",
      _default: "user@example.com"
    }
  });
  
  // Get field settings
  const emailSettings = contactWriteConfig.getSelectedFieldSettings("Email");
  
  // Set default value
  contactWriteConfig.setDefaultValues({
    fieldName: "Email",
    value: "default@example.com"
  });
  
  // Set write on create behavior
  contactWriteConfig.setWriteOnCreateSetting({
    fieldName: "Email",
    value: "ALWAYS"
  });
}
```

4. Complete Integration Example:
```typescript
function IntegrationConfig() {
  const config = useConfig();
  const { updateInstallation } = useUpdateInstallation();
  
  const handleSave = async () => {
    try {
      await updateInstallation({
        config: config.get(),
        onSuccess: () => {
          console.log("Configuration updated successfully");
        },
        onError: (error) => {
          console.error("Failed to update configuration:", error);
        }
      });
    } catch (error) {
      console.error("Error updating configuration:", error);
    }
  };
  
  return (
    <div>
      <ReadObjectConfig />
      <WriteObjectConfig />
      <button onClick={handleSave}>Save Configuration</button>
    </div>
  );
}
```

The `useConfig` hook provides a powerful and flexible way to manage your integration's configuration. It maintains a draft state that you can modify before committing changes to the installation. The hook's methods allow you to manage both read and write configurations for different objects, including field selections, mappings, and write behaviors.


## Examples

### Basic App Example
https://github.com/amp-labs/headless-basic-app

#### The Demo App has the following features:
- useConnections: manage when to show `<ConnectProvider/>`
- useManifest	: manage objects and metadata

#### Salesforce integration example
- field mapping interface: map dynamic fields to corresponding Salesforce fields
- connects with Salesforce through `<ConnectProvider/>`
- field metadata from Salesforce to populate available mapping options

####  Installation Management
- Install/Update: Creates or updates the Salesforce integration
- Reset: Syncs back to the server state
- Delete: Removes the installation

#### Installation Config Management
- local config state is managed by the `useConfig` hook
- provides getters and setters to manipulate the config object needed for installation mutations

#### Bring your own UI
Example using Shadcn UI components + Tailwind CSS


### Builder defined flow (no user input needed)
The config is able to be passed in directly if no additional config state management is needed.

```tsx
import {
  AmpersandProvider, ConnectProvider, useConnection, useInstallation,
} from '@amp-labs/react';

import { ConfigContent, AmpersandProviderOptions } from '@amp-labs/react/types';

const projectOptions: AmpersandProviderOptions ={
  apiKey: 'my-api-key',
  project: 'my-project',
}

const installationParams = {
  integration: 'my-hubspot-integration',
  consumerRef: 'user-123',
  groupRef: 'company-456',
};

export function App() {
  // Wrap your custom component inside of AmpersandProvider and InstallationProvider
  return (
    <AmpersandProvider options={projectOptions}>
      <InstallationProvider
        integration={installationParams.integration}
        consumerRef={installationParams.consumerRef}
        groupRef={installationParams.groupRef}
      >
        <MyIntegrationComponent />
      </InstallationProvider>
    </AmpersandProvider>
  );
}

// Static content for the installation, no user input needed
const myConfig: ConfigContent = {
  read: {
    objects: {
      contacts: {
        objectName: 'contacts',
        // Auto-select all fields to be read,
        // alternatively you can specify any desired fields & mappings here.
        selectedFieldsAuto: 'all',
      },
    }
};

function MyIntegrationComponent() {
  const {
    installation,
    isPending: isInstallationPending, // No data yet
    isFetching: isInstallationFetching, // Data is being refreshed
    isError: isInstallationError,
    error: installationError,
  } = useInstallation();
  
  const {
    connection,
    isPending: isConnectionPending, // No data yet
    isFetching: isConnectionFetching, // Data is being refreshed
    isError: isConnectionError,
    error: connectionError,
  } = useConnection(); 

  // Custom connection loading, error, and installation state overrides
  if (isConnectionPending || isInstallationPending) return <div>Loading </div>;
  if (isConnectionError) return <div>Error loading connection: {connectionError.message}</div>;
  if (isInstallationError) return <div>Error loading installation: {installationError.message}</div>;

  // The installation already exists
  if (!!installation) { return (<MyManageInstallationComponent />) } 

  if (connection) {
     createInstallation({ config: myConfig });
  };

  // Use Ampersand's built in UI for the Connection flow
  // This is the same as the existing ConnectProvider component but parameters
  // can be ommited since we are inside of InstallationProvider
  // When the connection is successful, this component will re-render since
  // `useConnection` will return the new connection.
  return (
     <ConnectProvider
        consumerRef={installationOptions.consumerRef}
        groupRef={installationOptions.groupRef}
     />
    </div>
  );
}
```

## Contributing

We welcome contributions to the Headless React Library. Please refer to our [contributing guidelines](https://github.com/amp-labs/react/blob/main/CONTRIBUTING.md) for more information.

## License

This library is licensed under the MIT License. See the [LICENSE](https://github.com/amp-labs/react/blob/main/LICENSE) file for details.
